from __future__ import annotations

from ape.mcp.implementations import (
    execute_database_query_impl,
    get_conversation_history_impl,
    get_database_info_impl,
    search_conversations_impl,
    get_last_N_user_interactions_impl,
    get_last_N_tool_interactions_impl,
    get_last_N_agent_interactions_impl,
    memory_append_impl,
    summarize_text_impl,
    call_slm_impl,
    list_available_resources_impl,
)
from ape.mcp.plugin import tool, get_registry
from ape.mcp.models import (
    ExecuteDatabaseQueryRequest, ExecuteDatabaseQueryResponse,
    ConversationHistoryRequest, ConversationHistoryResponse,
    SearchConversationsRequest, GenericTextResponse,
)
from ape.resources import read_resource as _read_resource

# Input schemas reused from server earlier definition

execute_query_schema = {
    "type": "object",
    "properties": {
        "query": {"type": "string", "description": "SQL query to execute"},
    },
    "required": ["query"],
}

@tool("execute_database_query", "Execute a read-only SQL query on the conversation database.", execute_query_schema)
async def execute_database_query(**kwargs):
    req = ExecuteDatabaseQueryRequest(**kwargs)
    result_text = await execute_database_query_impl(req.normalized_query)
    return ExecuteDatabaseQueryResponse(result=result_text).model_dump_json()

history_schema = {
    "type": "object",
    "properties": {
        "session_id": {"type": "string"},
        "limit": {"type": "integer", "default": 10},
    },
}

@tool("get_conversation_history", "Retrieve a specified number of recent messages from the current or a past conversation session.", history_schema)
async def get_conversation_history(**kwargs):
    req = ConversationHistoryRequest(**kwargs)
    result_json = await get_conversation_history_impl(req.session_id, req.limit)
    return result_json

@tool("get_database_info", "Get the schema and statistics of the conversation database.", {"type": "object", "properties": {}})
async def get_database_info(**_):  # accept & ignore any extraneous args
    return await get_database_info_impl()

search_schema = {
    "type": "object",
    "properties": {
        "query": {"type": "string"},
        "limit": {"type": "integer", "default": 5},
    },
    "required": ["query"],
}

@tool("search_conversations", "Search across all conversation history for messages matching a specific query.", search_schema)
async def search_conversations(**kwargs):
    req = SearchConversationsRequest(**kwargs)
    result_text = await search_conversations_impl(req.query, req.limit)
    return GenericTextResponse(result=result_text).model_dump_json()

@tool("list_available_tools", "List all tools currently registered and available for use by the agent.", {"type": "object", "properties": {}})
async def list_available_tools():
    """Dynamically lists all registered tools."""
    registry = get_registry()
    response = "Available MCP Tools:\n\n"
    for name, meta in registry.items():
        description = meta.get("description", "No description available.")
        response += f"📍 {name}\n"
        response += f"   Description: {description}\n\n"
    return response

@tool("list_available_resources", "List all read-only data resources that the agent can access using the 'read_resource' tool.", {"type": "object", "properties": {}})
async def list_available_resources():
    return await list_available_resources_impl()

n_inter_schema = {
    "type": "object",
    "properties": {
        "n": {"type": "integer", "default": 5},
        "session_id": {"type": "string"},
    },
}

@tool("get_last_N_user_interactions", "Retrieve the last N messages sent by the user in the current or a specified session.", n_inter_schema)
async def last_user_interactions(**kwargs):
    return await get_last_N_user_interactions_impl(kwargs.get("n", 5), kwargs.get("session_id"))

@tool("get_last_N_tool_interactions", "Retrieve the last N tool calls made by the agent in the current or a specified session.", n_inter_schema)
async def last_tool_interactions(**kwargs):
    return await get_last_N_tool_interactions_impl(kwargs.get("n", 5), kwargs.get("session_id"))

@tool("get_last_N_agent_interactions", "Retrieve the last N responses or thoughts generated by the agent in the current or a specified session.", n_inter_schema)
async def last_agent_interactions(**kwargs):
    return await get_last_N_agent_interactions_impl(kwargs.get("n", 5), kwargs.get("session_id"))

# ---------------------------------------------------------------------------
# 🆕 Memory append tool
# ---------------------------------------------------------------------------
memory_append_schema = {
    "type": "object",
    "properties": {
        "text": {
            "type": "string",
            "description": "The text content to embed and store."
        },
        "metadata": {
            "type": "object",
            "description": "Optional JSON metadata to store alongside the text."
        }
    },
    "required": ["text"]
}

@tool("memory_append", "Add a text snippet to the agent's long-term memory for future semantic search and retrieval.", memory_append_schema)
async def memory_append(**kwargs):
    """Expose :pyfunc:`ape.mcp.implementations.memory_append_impl` via MCP."""
    text: str = kwargs["text"]
    metadata: dict | None = kwargs.get("metadata")
    return await memory_append_impl(text, metadata)

# ---------------------------------------------------------------------------
# 🆕 Resource wrapper tool
# ---------------------------------------------------------------------------
resource_schema = {
    "type": "object",
    "properties": {
        "uri": {
            "type": "string",
            "description": "Registry URI to read (e.g. conversation://recent, schema://tables)"
        },
        "limit": {
            "type": "integer",
            "description": "Optional limit parameter supported by some resources",
            "default": 20
        },
        "q": {
            "type": "string",
            "description": "Optional query string for search-based resources."
        },
        "query": {
            "type": "string",
            "description": "Alias for 'q'."
        }
    },
    "required": ["uri"],
}

@tool("read_resource", "Access and retrieve content from a registered read-only data resource using its URI.", resource_schema)
async def read_resource_tool(uri: str, **kwargs):
    """Expose Resource Registry via a standard tool call so the LLM can read URIs autonomously."""
    ALLOWED_SCHEMES = ("conversation://", "schema://", "memory://")

    if not any(uri.startswith(s) for s in ALLOWED_SCHEMES):
        return f"SECURITY_ERROR: URI scheme not permitted: {uri}"

    try:
        # Handle alias for query parameter
        if "query" in kwargs and "q" not in kwargs:
            kwargs["q"] = kwargs.pop("query")

        mime, content = await _read_resource(uri, **kwargs)
        
        # Guard: cap payload size to 64k to avoid memory abuse
        MAX_LEN = 65536
        if len(content) > MAX_LEN:
            return "SECURITY_ERROR: Resource content exceeds safe size limit"

        # MIME-type whitelist – allow only safe text-based formats
        ALLOWED_MIME = ("application/json", "text/plain", "text/markdown")
        if mime not in ALLOWED_MIME:
            return f"SECURITY_ERROR: MIME type '{mime}' not permitted"

        return content
    except Exception as exc:
        return f"ERROR reading resource {uri}: {exc}"

# ---------------------------------------------------------------------------
# 🆕 Summarise Text Tool
# ---------------------------------------------------------------------------

summarize_schema = {
    "type": "object",
    "properties": {
        "text": {"type": "string", "description": "Text to be summarised (max 4000 tokens)"},
    },
    "required": ["text"],
}

@tool("summarize_text", "Generate a concise summary of a given text input.", summarize_schema)
async def summarize_text(**kwargs):
    """Expose :pyfunc:`ape.mcp.implementations.summarize_text_impl` via MCP."""
    # Pass through validated params to the impl function
    text: str = kwargs["text"]

    summary = await summarize_text_impl(text)
    # The tool contract demands *plain text* → ensure string return
    return summary

# ---------------------------------------------------------------------------
# 🆕 Call SLM Tool
# ---------------------------------------------------------------------------

call_slm_schema = {
    "type": "object",
    "properties": {
        "prompt": {
            "type": "string",
            "description": "The prompt to send to the Small Language Model."
        },
        "temperature": {
            "type": "number",
            "description": "Optional sampling temperature for the SLM."
        },
        "top_p": {
            "type": "number",
            "description": "Optional nucleus sampling parameter for the SLM."
        },
        "top_k": {
            "type": "integer",
            "description": "Optional top-k sampling parameter for the SLM."
        },
        "think": {
            "type": "boolean",
            "default": False,
            "description": "If true, the SLM will be instructed to think step-by-step."
        }
    },
    "required": ["prompt"],
}

@tool("call_slm", "Invoke a Small Language Model (SLM) to perform a quick, simple text generation or analysis task.", call_slm_schema)
async def call_slm(**kwargs):
    """Expose :pyfunc:`ape.mcp.implementations.call_slm_impl` via MCP."""
    return await call_slm_impl(**kwargs)